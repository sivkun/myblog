---
title: http协议
date: 2017-03-22 15:09:41
tags: [http]
categories: [协议]
---

> 可以[参考]( https://developer.mozilla.org/zh-CN/docs/Web/HTTP)，以及《图解HTTP》,进行学习


绝对URI格式
`http://user:pass@www.example.com:80/dir/index.html/uid=1#ch1`
http:或https:等协议方案名获取访问资源是要指定协议类型。不区分字母大小写，最后附一个冒号(:)

`http://`:协议方案名
`user:pass`:登录信息（认证）（可选）
`www.example.com`：服务器地址
`80`:服务器端口号
`/dir/index.html`:带层次的文件路径
`uid`：查询字符串
`ch1`:片段标识符

`RFC`:Request for Comments 征求修正意见书
通常，应用程序会遵照RFC确定的标准实现。可以说，RFC是互联网的设计文档，要是不按照RFC标准执行，就有可能导致无法通信的状况。

请求报文的构成
```js
POST(方法)  /form/entry(URI)  HTTP/1.1(协议版本) 

//请求首部字段
Host: example.com
Connection:keep-alive
Content-Type:appllication/x-www-form-urlencoded
Content-Length:16
//请求首部字段结束

//内容实体
name=sfqq&age=25
```

响应报文：
```js
HTTP/1.1 200 OK(状态码的原因短语)

Date: Wed, 22 Mar 2017 07:42:52 GMT
Content-Length:455
Content-Type:text/html

//主体
<html>
.... 
```

HTTP是一种不保存状态的协议，HTTP协议自身不对请求和响应之间的通信状态进行保存。这是为了更快的处理大量事务，确保协议可伸缩性，而特意把HTTP协议设计成如此简单。但为了事项期望的保持状态的功能，于是引入了Cookie技术。有了Cookie再用HTTP协议通信，就可以管理状态了。


HTTP/1.0和HTTP/1.1支持的方法

|方法|说明|支持的HTTP协议版本|
|-------|-----------|---------------------|
|GET|获取资源|1.0、1.1|
|POST|传输实体主体|1.0、1.1|
|PUT|传输文件|1.0、1.1|
|HEAD|获得报文首部|1.0、1.1|
|DELETE|删除文件|1.0、1.1|
|OPTIONS|询问支持的方法|1.1|
|TRACE|追踪路径|1.1|
|CONNECT|要求用隧道协议连接代理|1.1|
|LINK|简历和资源之间的联系|1.0|
|UNLINK|断开连接关系|1.0|


`持久链接keep-alive`
http协议的初始版本中，没进行一次HTTP通信就要断开一次客户端和服务器的TCP链接。
当页面复杂时，一个html页面中含有其他资源，因此每次的请求都会造成TCP连接的建立和断开，增加通信量的开销。
为了解决这个问题。http/1.1和一部分http/1.0想出了持久链接，特点是，只要任意一段没有明确提出断开连接，则保持TCP连接状态。
在HTTP/1.1中，所有的连接默认都是持久链接，但在HTTP/1.0内并未标准化。毫无疑问，除了服务器端，客户端也需要支持持久链接。

`管线化pipelining`
持久链接是的多数请求以管线化方式发送成为可能。从前发送请求后需要等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。


# http报文内的http信息

用于HTTP协议交互的信息被称为HTTP报文。

## 请求报文及响应报文的结构

1. 请求报文
* 报文首部
    具体：请求行、请求首部字段、通用首部字段、实体首部字段、其它
* 空行（CR+LF）
* 报文主体
2. 响应报文
* 报文首部
    具体：状态行、响应首部字段、通用首部字段、实体首部字段、其它
* 空行（CR+LF）
* 报文主体

请求行：包含用于请求的方法，请求URI和HTTP版本
状态行：包含表明响应结果的状态码，原因短语和HTTP版本。
首部字段：包含便是请求和响应的各种条件和属性的各类首部。
其它：可能包含HTTP的RFC里未定义的首部（Cookie等）

## 编码提升传输速率

http在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。编码的操作需要计算机来完成，因此会消耗更多的CPU等资源。

### 报文主体和实体主体的差异
* 报文（message）
 是HTTP通信的基本单位，由8位组字节流组成，通过HTTP通信传输
* 实体（entity）
 作为请求或响应的有限载荷数据被传输，其内容由实体首部和实体主体组成。

 HTTP报文的主体用于传输请求或响应的实体主体。
 同城报文主体等于实体主体。只有当（传输中进行编码）操作时，（实体主体的内容发生变化），才导致他和报文主体产生差异。

内容编码致命应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接受并负责解码。
常用内容编码格式：gzip（GNU zip），compress（unix系统的标准压缩），deflate（zlib），identity（不进行编码）
### 分割发送的分块传输编码
在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求的页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。
这种把实体分块的功能成为分块传输编码（Chunked transfer coding）

## 发送多种数据的多部分对象集合
    发送邮件时，我们可以在邮件里写入文字并添加多份附件。这是因为采用了MIME（Multipurpose Internet Mail Extensions，多用途因特网邮件扩展）机制。它允许邮件处理文本、图片、视频、等多各不同类型的数据。
    相应地，HTTP协议中也采纳了多部分对象集合（Multipart），发送的一份报文内可含有多类型实体。通常是在图片或文本文件上传时使用。
* multipart/form-data 在web表单文件上传时使用
* multipart/byteranges
  状态码206（partial content，部分内容）响应报文包含了多个范围的内容时使用。

一份报文中含有多类型实体，在报文实体中，每个类型实体，要使用某种标记分割标识哪种类型的实体。 在报文首部使用boundary来指定字符串来划分多部分集合指明各类实体。多部分对象集合的每个部分类型中，都可以含有首部字段。

## 获取部分内容的范围请求
    断点续传。
    对一份10000字节大小的资源，如果适用范围请求，可以只请求5001~10000字节的资源。
```js
    //请求
    GET /tip.jpg HTTP/1.1
    Host:www.example.com
    Range:bytes = 5001-10000
    //响应
    HTTP/1.1 206 Partial Content
    Date:Wed, 22 Mar 2017 07:42:52 GMT
    Content-Range:bytes 5001-10000/10000
    Content-Length:5000
    Content-Type:image/jpeg
```
* 从5001字节后的全部
`Range:bytes=5001-`
* 从一开始到3000字节和5000-7000字节的多重范围
`Range:bytes=-3000,5000-7000`
如果服务器端无法响应范围请求，则会返回状态码200 OK和完整的实体内容。

## 内容协商返回最合适的内容
    同一个web网站有可能存在多份相同内容的页面。比如英文版和中文版的web页面，他们内容虽然相同，但使用的语言却不同。
    当浏览器的默认语言为英文或中文，访问相同的URI的web页面时，则会显示对应的英文版或中文版的web页面。这种机制为内容协商。
内容协商机制是指客户端和服务端就响应的资源内容进行交涉，然后提供客户端最为合适的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断基准。
请求头：Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Language
内容协商技术三种类型：
* 服务器驱动协商
    由服务器端进行内容协商。以请求的首部字段为参考，在服务器端处理
* 客户端驱动协商
    由客户端进行内容协商，用户从浏览器显示的可选列表中手动选择。
* 透明协商
    是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。

# 返回结果的HTTP状态码
    状态码的职责就是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了
错误。
状态码的类别
||类别|原因短语|
|-------|----------|-------------|
|1xx|Informational(信息性状态码)|接受的请求正在处理|
|2XX|Success(成功状态码)|请求处理完毕|
|3XX|Redirection（重定向状态码）|需要进行附加操作以完成请求|
|4XX|ClientError（客户端错误状态码）|服务器无法处理请求|
|5XX|ServerError（服务器端错误状态码）|服务器处理请求出错|
200 请求成功
204 No Content 请求处理成功，但没有资源可返回。
206 Partial Content 对资源某一部分请求。
301 Moved Permanently 永久性重定向
302 Found 临时性重定向
303 see other
    该状态码便是由于请求对应的资源存在着另一个URI，应使用GET方法重定向获取请求的资源，303状态码和302Found状态码有着相同的功能，
但303状态码明确便是客户端应当采用GET方法获取资源，这点与302状态码有区别。
    当301/302/303响应状态码返回时，几乎所有的浏览器都会把POST改为GET，并删除请求报文内的主体，之后请求会自动再次发送。
301/302标准是禁止将POST方法改变为GET方法的，但实际上使用时大家都这么做了。
304 Not Modified
    该状态码表示客户端发送附带条件的请求（指请求报文还包含If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since中任一首部）时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，布包好任何响应的
主体
部分。304虽然别划分在3XX类别中，但是和重定向没有关系。
307 Temporary Redirect 临时重定向
 该状态码与302 Found有着相同的含义。307会遵照浏览器标准，不会从POST变为GET。但是，对于处理响应时的行为，每种浏览器有可能
 出现不同的情况。
400 Bad Request
该状态码便是报文中存在语法错误。浏览器回想200OK一样对待该状态码。
401 Unauthorized
403 Forbidden
404 Not Found
500 Internal Server Error
503 Service Unavailable
# 与HTTP协作的Web服务器
    一台Web服务器可搭建多个独立域名的Web站点，也可作为通信路径上的中转服务器提升传输效率。
## 通信数据转发程序：代理、网管、隧道
* 代理：
    代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端‘中间人’的角色，接收由客户端发送的请求并转发给服务器，同时接收服务器
返回的响应并转发给客户端。

* 网关
    网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的服务器一样对请求进行处理。有时客户端可能
都不会察觉，自己通信目标是一个网关。
* 隧道
    隧道是在相隔甚远的客户端和服务器两者之间进行中转，并支持双方通信连接的应用程序。

### 代理
    代理服务器的基本行为就是接收客户端发送的请求后转发给其它服务器。
    使用代理服务器的理由有：利用缓存技术减少网络带宽的流量，阻止内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。
    代理有多重使用方法，按两种基准分类。一种是是否使用缓存，另一种是是否会修改报文。
* 缓存代理
代理转发响应时，缓存代理会预先将资源的副本保存在代理服务器上。当代理再次接收到相同资源的请求时，就可以不从原服务器那里获取资源。而是将之前缓存的资源作为响应返回。
* 透明代理
转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理。反之称为非透明代理。
### 网关
利用网关可以由HTTP请求转化为其它协议通信。

## 保存资源的缓存
    缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对资源服务器的访问，因此也就节省了通信流量和通信时间。
    缓存服务器是代理服务器的一种。
    缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。因此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同
的请求了。
### 缓存的有效期限
    即便缓存服务器内有缓存，也不能保证每次都会返回对资源的请求。因为这关系到被缓存资源的有效性问题。
    即时存在缓存，也会因为客户端的要求、缓存的有效期等因素，向原服务器确认资源的有效性。若判断缓存失效，缓存服务器将会再次从源服务
器上获取‘新’资源。
### 客户端的缓存
    缓存不紧可以存在于缓存服务器内，还可以存在客户端浏览器中。以IE为例，客户端缓存称为临时网络文件。
    浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取。当判定缓存过期后，会向源服务器确认资源的有效性。若判断浏览器缓存失效，浏览器会再次请求资源。
# HTTP首部
 在报文众多的字段中，HTTP首部字段包含的信息最为丰富。首部字段同时存在于请求和响应报文内，并涵盖HTTP报文相关的内容信息。
## HTTP首部字段
HTTP首部字段传递重要的信息
### HTTP首部字段结构
`首部字段名：字段值`
* 若HTTP首部字段重复了会如何？
    这种情况在规范内尚未明确，根据浏览器内部处理逻辑的不同，结果可能并不一致。有的优先处理第一次出现的首部字段，有的有限处理最后出现的首部字段等。
### 4中HTTP首部字段类型
1. 通用首部字段（general header fields）
请求报文和响应报文两方都会使用的首部。
2. 请求首部字段（request header fields）
3. 响应首部字段（response headerfields）
4. 实体首部字段（entity header fields）

HTTP/1.1和非HTTP/1.1首部
非HTTP/1.1首部字段：Cookie、Set-Cookie和Content-Disposition等

### End-to-End 首部和 Hop-by-hop首部
* 端到端首部
    该类首部会转发给请求/响应对应的最终接收目标，切必须保存在由缓存生成的响应中，另外规定它必须被转发
* 逐跳首部
    该类首部只对单次转发有效，会因通过缓存或代理而不再转发。在HTTP/1.1和之后版本中，如果使用hop-to-hop首部，需提供Connection首
部字段。有如下逐跳首部字段：
1. Connection
2. Keep-Alive
3. Proxy-Authenticate
4. Proxy-Authorization
5. Trailer
6. TE
7. Transfer-Encoding
8. Upgrade
## HTTP/1.1通用首部字段
### Cache-Control
    通过指定该字段，可以操作缓存的工作机制。
指令格式，例如：
`Cache-Control:private,max-age=0,no-cache`
缓存请求指定：
|指令|参数|说明|
|-----|------|---------------|
|no-cache|无|强制向源服务器再次验证|
|no-store|无|不缓存请求或响应的任何内容|
|max-age=[秒]|必须|响应的最大Age值|
|max-stale(=[秒])|可省略|接受已经过期的响应|
|min-fresh=[秒]|必须|期望在指定时间内的响应仍然有效|
|no-transform|无|代理不可改变媒体类型|
|only-if-cached|无|从缓存获取资源|
|cache-extension|-|新指令标记（token）|

缓存响应指令
|指令|参数|说明|
|------|------|-----------|
|public|无|可向任一方提供响应的缓存|
|private|可省略|仅向特定用户返回响应|
|no-cache|可省略|缓存前必须先确认其有效性|
|no-store|无|不缓存请求或响应的任何内容|
|no-transform|无|代理不可更改媒体类型|
|must-revalidate|无|可缓存必须向源服务器进行确认|
|proxy-revalidate|无|要求中间缓存服务器对缓存的响应有效性再进行确认|
|max-age=[秒]|必须|响应的最大Age值|
|s-maxage=[秒]|必须|公共缓存服务器响应的最大Age值|
|cache-extension|-|新指令标记（token）|


**表示是否能缓存的指令**
public指令
`Cache-Control:public`,表示其它用户可以利用缓存
private指令
`Cache-Control:private`,表示缓存服务器会对特定用户提供资源缓存的服务，对于其它用户发来的请求，代理服务器则不会返回缓存。
no-cache指令
`Cache-Control:no-cache`，表示不缓存过期的资源，缓存会向源服务器进行有效性确认后处理资源。
**控制可执行缓存的对象的指令**
no-store指令
`Cache-Control:no-store`,暗示请求或响应中包含机密信息，不进行缓存。
**指定缓存期限和认证的指令**
s-maxage指令
`Cache-Control:s-maxage=604800`（单位：秒）一周
    该指令的功能和max-age指令相同，它们的不同点是s-maxage指令只适用于供多为用户使用的公共缓存服务器。也就是说对于向同一用户重复
返回响应服务器来说，这个指令没有任何作用。当使用s-maxage指令后，则直接忽略对Expires首部字段及max-age指令的处理。
max-age指令
`Cache-Control:max-age=604800`
    客户端发送的请求中包含max-age指令时，如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接受缓存的资源。另外，当
max-age=0，那么缓存服务器通常需要将请求转发给源服务器。
    服务器返回的响应中包含max-age时，缓存服务器将不对资源的有效性再做确认，而max-age数值代表资源保存为缓存的最长时间。
    应用HTTP/1.1版本的缓存服务器遇到同时存在Expires首部字段的情况时，会优先处理max-age指令，而忽略掉Expires首部字段。
而HTTP/1.0版本的缓存服务器的情况却相反，max-age指令会被忽略。
min-fresh指令
`Cache-Control:min-fresh=60`
    客户端询问缓存服务器，再过60秒这个资源还是新的吗（过期了吗）？不是的话，则不能用缓存做响应。
max-stale指令
`Cache-Control:max-stale=3600`
使用max-stale可只是缓存资源，即时过期也照常接受。

### Connection
    两个作用：
* 控制不再转发给代理的首部字段
```js
//客户端发送请求
    GET / HTTP/1.1
    Upgrade: HTTP/1.1
    Connection:Upgrade
//经过一个代理转发后
    GET / HTTP/1.1
//首部字段Upgrade被删除后再转发
```
* 管理持久链接
`Connection:close`
HTTP/1.1默认链接都是持久化链接。为此，客户端会在持久化链接上连续发送请求。当服务器端向明确断开连接时，则指定Connection首部字段为Close。
`Connection:Keep-Alive`
HTTP/1.1之前的HTTP版本的默认链接都是非持久链接。为此想在旧版本的HTTP协议上维持持续连接，则需要指定Connection首部字段值为Keep-Alive.
### Date
首部字段Date标明创建HTTP报文的日期和时间。
### Trailer
    首部字段Trailer会事先说明咋报文主体后记录了哪些首部字段。该首部子弹壳应用在HTTP/1.1版本分块传输编码时。
### Transfer-Encoding
    首部字段Transfer-Encoding规定了传输报文主体时采用的编码方式。
    HTTP/1.1的传输编码方式仅对分块传输编码有效
### Via
    使用首部字段via是为了追踪客户端与服务器端之间的请求和响应报文的传输路径。
    是偶不字段Via不紧用于追踪报文的转发，还可以避免请求回环的发生。所以必须在经过代理是附加该首部字段内容。
## 请求首部字段
    请求首部子弹是从客户端往服务器端发送请求报文所使用的字段，用于补充请求的附加信息，客户端信息，对响应内容相关的优先级等内容。
### Accept
`Accept:text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`
Accept首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的优先级。可以使用type/subtype这种形式，一次指定多种媒体类型。
例子：
* 文本文件
text/html,text/plain,text/css...
application/xhtml+xml,application/xml...
* 图片文件
image/jpeg,image/gif,image/png...
* 视频文件
video/mpeg,video/quicktime...
* 应用程序使用的二进制文件
application/octet-stream,application/zip...

若想要给显示的媒体类型增加优先级，则使用q=来二外表示权重值，用分号（;）进行分割。

### Accept-Charset
`Accept-Charset:iso-8859-5,unicode-1-1;q=0.8`
   该字段可用来通知服务器用户代理支持的字符集及字符集的相对有限顺序。另外可一次性指定多种字符集。与首部字段Accept相同的是可用权重
q值来表示相对优先级。
    该首部字段应用于内容协商机制的服务器驱动协商。
### Accept-Encoding
`Accept-Encoding:gzip,deflate`
Accept-Encoding首部告知服务器用户代理支持的内容编码及内容编码的优先级顺序，可一次性指定多种内容编码。
### Accept-Language
`Accept-Language:zh-cn,zh;q=0.7,en-us,en;q=0.3`
客户端在服务器有中文版资源的情况下，会请求其返回中文版对应的响应，没有中文版，则请求返回英文版响应。
### Authorization
`Authorization:Basic ddsfkdasfldasfkasdf=`
    首部字段Authorization是用来告诉服务器，用户代理的认证信息。
### Expect


